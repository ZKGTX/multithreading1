package com.zerokikr.lesson6;

/* Свой класс реализует интерфейс Runnable или наследуется от класса Thread.
 * 
 * Метод run() переопределяется: прописывается задача, которую необходимо выполнить.
 * 
 * В main создается объект класса, реализующего Runnable или унаследованного от Thread,
 * 	  у объекта вызывается метод start().
 * 
 * Если запустить run(), то поток не запустится, а выполнится метод run() внутри main thread.
 * 
 * Если нужно, чтобы main тред дождался, пока отработает другой тред,
 *  то в main нужно вызвать метод join() у объекта треда, который нужно дождаться (sampleThread.join()).
 *  
 * У каждого потока свой StackTrace. Локальные переменные у каждого треда свои.
 * 	 Heap для всех тредов общий, но на каждый тред выделяется своя область.
 * 	 Java гарантирует потокобезопасность и неблокируемость создания объектов. 
 *  
 * Приложение работает пока работает хотя бы один обычный тред. 
 * 
 * Если в приложении есть служебная задача, которую не жалко в любой момент остановить,
 * 		ее можно назначить Daemon-треду, который прервет свою работу как только
 * 		все обычные треды отработают. 
 * 
 * У daemon-треда нет привязки к породившему его треду. Он прервет свою работу только 
 * 	   когда отработает последний обычный тред.
 * 
 * stop() останавливает тред чтобы он ни делал, так можно испортить или потерять данные.
 * 	   НЕ использовать stop().
 * 
 * Чтобы прервать работу треда правильно, нужно вызвать метод interrupt(),
 * 	   предварительно заложив в метод run() треда проверку isInterrupted().
 * 	   Без проверки isInterrupted() метод interrupt() не сработает.
 * 
 * Если поток спит/не воспринимает внешние команды, то при вызове interrupt() он выкинет
 * 	   InterruptedException. В этом случае можно добавить в run() свой boolean = false и 
 * 	   перевести его в true внутри исключения, и делать проверку на него вместе с isInterrupted().
 * 
 * Мы не можем гарантировать порядок действий параллельных потоков.
 * 
 * Race condition возникает, когда два (или более) треда работают с одним и тем же набором данных.
 * 		   
 * synchronized в сигнатуре метода означает, что в метод может зайти только один тред,
 * 		и пока этот тред работает с методом, другой тред к методу обратиться не может.
 * 		Такая синхронизация позволяет избежать Race Condition.
 * 
 * Блок кода, помеченный synchronized, называется критической секцией.
 * 
 * Монитор - это объект, на который смотрит тред при заходе в блок кода.
 * 	 Если монитор занят	другим тредом, то надо зайти попозже, когда монитор освободится.
 * 
 * Если использовать synchronized в сигнатуре метода, то монитором становится объект, 
 * 	   у которого этот метод вызван. 
 * 
 * Монитором может быть любой объект (функционал прописан в классе Object).
 * 		Это значит, что можно создать Object monitor и с его помощью
 * 		синхронизировать (synchronized(monitor)) часть кода метода, а не весь метод.
 * 
 * Если указать synchronized в сигнатуре static метода, то в один момент времени
 * 		только один тред сможет вызывать у данного класса этот synchronized static метод.
 * 		В роли монитора будет выступать сам класс.
 * 
 * 3 способа синхронизировать работу тредов:
 * 	 1) ключевое слово synchronized в сигнатуре обычного метода
 * 	 2) ключевое слово synchronized в сигнатуре статического метода
 * 	 3) блок кода synchronized (monitor) {}, где monitor - специально созданный 
 * 		объект (Object monitor = new Object()) или существующий объект в программе.
 * 
 * Синхронизироваться между тредами можно с помощью monitor.wait(). 
 * 	 В момент wait() monitor освобождается, тред ожидает и не тратит время процессора.
 * 	 monitor.notify() и monitor.notifyAll() будят потоки, которые ждут по тому же monitor.
 * 	 Если тредов больше двух, то notify() разбудит какой-то из тредов (точно не узнать какой).
 * 
 * Ключевое слово volatile при объявлении переменной запрещает кэшировать данные в ядре
 * 	 процессора (переменная всегда будет находиться в общей памяти и будет видна всем работающим тредам).
 * 	 volatile решает проблему с видимостью данных, но не избавляет от race condition.
 *	 
 * 
 */ 

public class ThreadsInfo {
	
}
